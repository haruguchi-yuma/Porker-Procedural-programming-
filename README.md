# Porker (Procedural-programming)
フィヨルドブートキャンプ、勝手にモブプロ用問題です。
この問題は[TDD Boot Camp\(TDDBC\) \- TDDBC仙台07/課題](http://devtesting.jp/tddbc/?TDDBC%E4%BB%99%E5%8F%B007%2F%E8%AA%B2%E9%A1%8C)を参考に改編して作っています。

# モブプログラミングのやり方
一定時間ごとに後述する**ドライバー**と**モブ**を入れ替えながら複数人でプログラミングをおこなっていく。
## 役割
1. **ドライバー**（タイピスト）
    - モブプログラミングの文脈ではタイピストというが、ここでは言い慣れているドライバーという用語を使う。
    - 司会進行。タイピングを行う人。モブ（後述）が話し合って決めたコードを打ち込む。
    - タイピングしたコードに関して、理解していない状態で進めてはいけない。
    - ドライバーはモブが決定したコードに対して理解していなければ質問をする責任を負う。
2. **モブ**　ドライバー以外の人
    - 主に実装の方針を話し合って決める
   - キーボードを使って入力することはできない
   - 特定のモブが勝手に進めてはいけない（モブ同士の同意の上で方針を決定する）
   - ドライバーからの質問に答える
## 言葉の定義
- **トランプ**
  - 4種類のスート(マーク)と1から13までのランク(数字)を組み合わせた52枚からなるカード
  - 今回Jokerはないものとする
- **Card(カード)**
  - Suit(スート)とrank(ランク)からなる
  - **Suit(スート)**
    - 以下4種類のマークを持つ
    - ♠️(スペード/spade)
    - ♥(ハート/heart)
    - ♣️(クラブ/club)
    - ♦︎(ダイヤ/diamond)
  - **Rank(ランク)**
    - 以下13種類の数字をもつ
    - A(エース/ace), 2, 3, 4, 5, 6, 7, 8, 9, 10, J(ジャック/jack), Q(クィーン/queen), K(キング/king)
- **Deck(デッキ)**
  - 4(Suit) × 13(Rank) = 52枚のカード1組のことをDeck(デッキという)

## 問題
### (1)　SuitやRankをランダムに生成し、文字列で返すメソッドを作成してください。

ただし、必ず`rank→suit`の順になるような文字列にすること。
```ruby
# これは一例です。
generated_card
=> "8♠️"


generated_card
=> "A♦︎"
```

### (2) 2枚のカードを比較できるようなメソッドを作成してください。
2枚のカードにおいて、
- Suitが同じかどうか判定するメソッド
- Rankが同じかどうか判定するメソッド
- SuitとRankがそれぞれ同じかどうか判定するメソッド
を作成してください。

```ruby
# コードは一例です
same_rank?(card1, card2) #=> true or false
same_suit?(card1, card2) #=> true or false
```

### (3)　カードを2枚生成し、その役を判定するメソッドを作成してください
ツーカードポーカーにおいての役は以下の通り

- **ストレートフラッシュ (straight flush)**
  - ストレートとフラッシュが成立している
- **ペア (pair)**
  - 2枚のカードが同じランクを持つ
- **ストレート (straight)**
  - 2枚のカードのランクが連続している
    A は 2 と K の両方と連続しているとみなす (A-K および 2-A のランクの組み合わせはいずれもストレートである)
- **フラッシュ (flush)**
  - 2枚のカードが同じスートを持つ
- **ハイカード (high card)**
  - 上記の役が1つも成立していない

実装要件は要件は以下の通り

- 異なるカードを2枚生成する
- 役を判定し、役と手札の情報を標準出力する

```ruby
# 出力例

play_2cards_porker
#=> hand: straight, cards: 'A♦︎' と 'K♥'
```

### (4) 2つの手札の強さを比較できるようにしてください。
強さの比較においての要件は以下の通りです。

- 上位の役を持っている手札が強い
- 2つの手札が同じ役を持つ場合はRankによって決まる。
  - Rankの強さ `(弱) 2 < 3 < 4 < 5 < ... < J < Q < K < A (強)`
- **ストレートフラッシュ**
  - 一番強いランクを持つカード同士を比較する (ただし、2-A のランクの組み合わせの場合は、2 を一番強いランクとする (A-K が最強、2-A が最弱))
  - 一番強いランクが同じ場合は引き分け
- **ペア**
  - ペアのランクを比較する
  - ペアのランクが同じ場合は引き分け
- **ストレート**
  - 一番強いランクを持つカード同士を比較する (ただし、2-A のランクの組み合わせの場合は、2 を一番強いランクとする (A-K が最強、2-A が最弱))
  - 一番強いランクが同じ場合は引き分け
- **フラッシュ**
  - 一番強いランクを持つカード同士を比較する
  - 上記が同じランクの場合は、もう一枚のカード同士を比較する
  - 上記が同じランクの場合は引き分け
- **ハイカード**
  - 一番強いランクを持つカード同士を比較する
  - 上記が同じランクの場合は、もう一枚のカード同士を比較する
  - 上記が同じランクの場合は引き分け(つまり2枚とも同じ場合)

実装要件は以下の通りです

- 2つの手札を引数に渡す
- 手札の情報と勝ち負けを標準出力する

```ruby
# 標準出力例

judge_2cards_porker(cards1, cards2)
#=> cards1 hand: pare, cards: `6♣️' と '7♦︎', judge: win
#=> cards2 hand: high card, cards: 'A♥' と 'J♦︎', judge: lose

# 引き分けの場合
judge_2cards_porker(cards1, cards2)
#=> cards1 hand: straight flush, cards: `A♣️' と 'K♦︎', judge: draw
#=> cards2 hand: straight flush, cards: `A♣️' と 'K♦︎', judge: draw
```
